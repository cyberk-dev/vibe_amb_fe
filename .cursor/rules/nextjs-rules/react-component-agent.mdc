---
description: "Defines React component architecture patterns for presentation and container components, focusing on separation of concerns, prop management, and composition patterns. Apply when creating new components, refactoring existing components, or designing component hierarchies."
globs: apps/web/**/*.tsx, packages/ui/**/*.tsx
alwaysApply: true
---

# React Component Architecture Standards

You are a React component architect. Follow these strict patterns for component organization and structure.

## Core Principles

- **Container-Based Architecture**: Containers manage business logic via hooks and may include UI
- **Flexible Separation**: Separate presentation components only when complexity justifies it
- **React Hook Form**: Container components using forms should integrate React Hook Form directly
- **Hook Integration**: All data fetching and mutations happen through React Query hooks
- **Composition Over Props**: Use component composition to avoid excessive prop drilling
- **Explicit Contracts**: Define clear TypeScript interfaces for all component props
- **Single Responsibility**: Each component serves a single, well-defined purpose

## Component Architecture Types

### Presentation Components
- **Purpose**: UI display and internal state management only
- **File naming**: `{component-name}.tsx`
- **Characteristics**:
  - Pure components without side effects
  - Handle only internal UI state (form inputs, toggles, local animations)
  - Receive callback props to communicate state changes to parent
  - Maximum 3 layers of prop drilling allowed
  - Use composition pattern for complex component trees
  - No direct API calls or business logic

### Container Components
- **Purpose**: Business logic orchestration and UI composition
- **File naming**: `{component-name}-container.tsx`
- **Characteristics**:
  - Handle all business logic and data fetching via hooks
  - Manage application state via Zustand stores and React Query
  - Use custom hooks for data and side effects
  - **May include UI components** (forms, layouts) while managing their logic
  - Handle error states and loading states
  - Manage side effects through React Query hooks and custom hooks
  - Can be full-featured components that combine logic + UI, not just orchestrators

## Implementation Rules

### ✅ Correct Implementation

**Presentation Component Example:**
```tsx
// user-profile.tsx
interface UserProfileProps {
  name: string;
  email: string;
  avatar?: string;
  onEdit: () => void;
  onDelete: () => void;
}

export function UserProfile({ 
  name, 
  email, 
  avatar, 
  onEdit, 
  onDelete 
}: UserProfileProps) {
  return (
    <div className="user-profile">
      <Avatar src={avatar} alt={name} />
      <div className="user-info">
        <h3>{name}</h3>
        <p>{email}</p>
      </div>
      <div className="actions">
        <Button onClick={onEdit}>Edit</Button>
        <Button onClick={onDelete} variant="destructive">Delete</Button>
      </div>
    </div>
  );
}
```

**Container Component Example (with integrated UI):**
```tsx
// login-container.tsx
"use client";

import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import * as z from "zod";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { useLoginMutation } from "@/integrations/api";

const loginSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(6, { message: "Password must be at least 6 characters" }),
});

type LoginFormValues = z.infer<typeof loginSchema>;

interface LoginContainerProps {
  onSuccess?: () => void;
}

export const LoginContainer = ({ onSuccess }: LoginContainerProps) => {
  // Business logic: hooks for data fetching and mutations
  const loginMutation = useLoginMutation();

  // Form state management
  const loginForm = useForm<LoginFormValues>({
    resolver: zodResolver(loginSchema),
    defaultValues: {
      email: "",
      password: "",
    },
  });

  // Business logic: form submission handler
  const onLoginSubmit = async (data: LoginFormValues) => {
    try {
      await loginMutation.mutateAsync({ username: data.email, password: data.password });
      loginForm.reset();
      onSuccess?.();
    } catch (error) {
      console.error("Login error:", error);
    }
  };

  // UI rendering integrated with business logic
  return (
    <div className="space-y-4">
      <Form {...loginForm}>
        <form onSubmit={loginForm.handleSubmit(onLoginSubmit)} className="space-y-4">
          <FormField
            control={loginForm.control}
            name="email"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Email</FormLabel>
                <FormControl>
                  <Input placeholder="Enter your email" {...field} disabled={loginMutation.isPending} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <FormField
            control={loginForm.control}
            name="password"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Password</FormLabel>
                <FormControl>
                  <Input
                    type="password"
                    placeholder="Enter your password"
                    {...field}
                    disabled={loginMutation.isPending}
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />

          <Button type="submit" className="w-full" disabled={loginMutation.isPending}>
            {loginMutation.isPending ? "Logging in..." : "Log In"}
          </Button>
        </form>
      </Form>
    </div>
  );
};
```

**Alternative: Container with Separate Presentation (when UI is complex):**
```tsx
// user-profile-container.tsx
import { useUserQuery, useUpdateUserMutation } from '@/integrations/api';
import { toast } from 'sonner';
import { UserProfileForm } from './_components/user-profile-form';

interface UserProfileContainerProps {
  userId: string;
}

export const UserProfileContainer = ({ userId }: UserProfileContainerProps) => {
  const { data: user, isLoading } = useUserQuery(userId);
  const updateUserMutation = useUpdateUserMutation();

  const handleSubmit = async (data: UserFormData) => {
    try {
      await updateUserMutation.mutateAsync({ id: userId, ...data });
      toast.success('Profile updated successfully');
    } catch (error) {
      toast.error('Failed to update profile');
    }
  };

  if (isLoading) return <div>Loading...</div>;
  if (!user) return <div>User not found</div>;

  return (
    <UserProfileForm
      defaultValues={user}
      onSubmit={handleSubmit}
      isLoading={updateUserMutation.isPending}
    />
  );
};
```

### ❌ Wrong Implementation

**Mixing Concerns (Bad):**
```tsx
// user-profile.tsx - WRONG: Business logic in presentation component
export function UserProfile({ userId }: { userId: string }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(false);

  // WRONG: Side effects and business logic
  useEffect(() => {
    async function fetchUser() {
      setLoading(true);
      try {
        const userData = await api.getUser(userId);
        setUser(userData);
      } catch (error) {
        console.error('Failed to fetch user');
      }
      setLoading(false);
    }
    fetchUser();
  }, [userId]);

  // WRONG: Business logic in presentation component
  const handleDelete = async () => {
    try {
      await api.deleteUser(userId);
      setUser(null);
    } catch (error) {
      alert('Failed to delete user');
    }
  };

  return (
    <div>
      {loading ? <div>Loading...</div> : (
        <div>
          <h3>{user?.name}</h3>
          <Button onClick={handleDelete}>Delete</Button>
        </div>
      )}
    </div>
  );
}
```

**Excessive Prop Drilling (Bad):**
```tsx
// WRONG: More than 3 layers of prop drilling
function App() {
  const user = useUser();
  return <Layout user={user} />;
}

function Layout({ user }: { user: User }) {
  return <Sidebar user={user} />;
}

function Sidebar({ user }: { user: User }) {
  return <Navigation user={user} />;
}

function Navigation({ user }: { user: User }) {
  return <UserMenu user={user} />;
}

function UserMenu({ user }: { user: User }) {
  return <Avatar src={user.avatar} />;
}
```

**Better Composition Pattern:**
```tsx
// CORRECT: Use composition to avoid prop drilling
function App() {
  const user = useUser();
  return (
    <Layout>
      <Sidebar>
        <Navigation>
          <UserMenu user={user} />
        </Navigation>
      </Sidebar>
    </Layout>
  );
}
```

## Directory Structure & Component Organization

### Shared UI Components (`packages/ui/`)
```plaintext
packages/ui/src/components/
├── button/
│   ├── button.tsx              # Presentation component
│   └── index.ts               # Export barrel
├── form/
│   ├── form-field.tsx         # Presentation component  
│   ├── form-container.tsx     # Container component (if needed)
│   └── index.ts               # Export barrel
└── layout/
    ├── sidebar.tsx            # Presentation component
    └── index.ts               # Export barrel
```

### Application Components
```plaintext
src/
├── app/(demo)/auth/
│   ├── page.tsx                      # Page component
│   ├── _components/                  # Optional presentation components
│   │   ├── login-form.tsx            # Pure presentation form
│   │   └── social-buttons.tsx        # Social login buttons
│   └── _containers/                  # Container components
│       ├── login-container.tsx       # Login with integrated UI
│       ├── register-container.tsx    # Register with integrated UI
│       └── auth-form-container.tsx   # Main auth form orchestrator
├── components/                       # Global shared components
│   ├── layout/
│   │   ├── header.tsx                # Global header
│   │   ├── footer.tsx                # Global footer
│   │   └── protected-sidebar.tsx     # Protected area sidebar
│   ├── auth/
│   │   ├── require-role.tsx          # RBAC wrapper component
│   │   └── show-for-role.tsx         # Conditional render by role
│   └── ui/                           # shadcn/ui components
│       ├── button.tsx
│       ├── input.tsx
│       └── form.tsx
```

## Critical Architecture Rules

- **Container Patterns**: Container components can follow two patterns:
  1. **Integrated**: Combine hooks + UI + logic in one component (common for forms, simple pages)
  2. **Separated**: Use presentation components when UI complexity justifies separation

- **Component Purity** (when using separated presentation):
  - Presentation components MUST NOT contain:
    - Direct API calls or data fetching
    - Business logic or calculations
    - React Query hooks or mutations
    - Store subscriptions or mutations
    - Route navigation logic

- **Container Responsibility**: Container components MUST:
  - Use React Query hooks for all data fetching and mutations
  - Use React Hook Form for form state management
  - Handle loading and error states
  - Use Zustand stores for application state
  - Manage route navigation
  - Include UI when appropriate (forms, layouts)

- **Prop Flow** (when using separated presentation):
  - Container → Presentation (data and callbacks)
  - Presentation → Container (via callback props)
  - Avoid excessive prop drilling (max 2-3 levels)

- **Import Patterns**:
  - Use `@/` for all absolute imports
  - Use relative imports for co-located components (`_components/`, `_containers/`)
  - Import from `@/integrations/api` for React Query hooks
  - Import from `@/components/ui` for shadcn/ui components

- **State Management**:
  - Form state → React Hook Form (in containers)
  - Local UI state → useState (in containers or presentations)
  - Application state → Zustand stores
  - Server state → React Query hooks (only in containers)

## Testing Strategy

- **Presentation Components**: Unit tests focused on rendering and user interactions
- **Container Components**: Integration tests simulating real user workflows
- **Shared Components**: Storybook stories and visual regression testing (recommended)
