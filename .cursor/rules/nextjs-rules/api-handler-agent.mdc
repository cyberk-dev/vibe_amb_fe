---
description: "Defines standards for API integration patterns in Next.js applications. Container components must not directly interact with APIs - they should communicate via React Query hook wrappers. Apply when implementing data fetching, API calls, or server state management."
globs: "**/{hooks,api,components}/**/*.{ts,tsx}"
alwaysApply: true
---

# API Handler Integration Standards

## Core Principles

- **Hook-Based API Integration**: All API calls must be wrapped in React Query hooks
- **Container Isolation**: Container components never directly call APIs - they use hooks only
- **Centralized API Logic**: Business logic and error handling encapsulated in custom hooks
- **Type Safety**: Full TypeScript integration for API requests and responses
- **React Query First**: Follow React Query best practices for all server state management

## Architecture Pattern

### ✅ Correct Implementation Flow

```
API Service → React Query Hook → Container Component
```

### Component Responsibility Chain

1. **API Services Layer** (`src/integrations/api/services/`) - Raw API functions and types
2. **React Query Hooks Layer** (`src/integrations/api/hooks/`) - React Query wrappers with business logic
3. **Container Layer** (`src/app/**/_containers/`) - Uses hooks, handles logic, includes UI
4. **Presentation Layer** (Optional, `src/app/**/_components/`) - Pure UI components when separated

## Implementation Rules

### 1. API Services Layer Structure

```typescript
// ✅ GOOD: src/integrations/api/services/user.ts - Pure API functions
import { apiClient } from '../core/client';

export interface User {
  id: string;
  name: string;
  email: string;
  role: string;
}

export interface GetUsersParams {
  page?: number;
  limit?: number;
}

export const getUsers = async (params?: GetUsersParams): Promise<User[]> => {
  const response = await apiClient.get<User[]>('/users', { params });
  return response.data;
};

export const getUserById = async (id: string): Promise<User> => {
  const response = await apiClient.get<User>(`/users/${id}`);
  return response.data;
};

export const promoteToAdmin = async (userId: string): Promise<User> => {
  const response = await apiClient.post<User>(`/users/${userId}/promote`);
  return response.data;
};

export const demoteFromAdmin = async (userId: string): Promise<User> => {
  const response = await apiClient.post<User>(`/users/${userId}/demote`);
  return response.data;
};
```

```typescript
// ✅ GOOD: src/integrations/api/services/auth.ts - Auth API functions
import { apiClient } from '../core/client';

export interface LoginRequest {
  username: string;
  password: string;
}

export interface AuthResponse {
  jwt: string;
  jwtRefresh: string;
  user: {
    id: string;
    email: string;
    role: string;
  };
}

export const login = async (credentials: LoginRequest): Promise<AuthResponse> => {
  const response = await apiClient.post<AuthResponse>('/auth/login', credentials);
  return response.data;
};

export const register = async (userData: RegisterRequest): Promise<AuthResponse> => {
  const response = await apiClient.post<AuthResponse>('/auth/register', userData);
  return response.data;
};
```

### 2. React Query Hooks Layer

```typescript
// ✅ GOOD: src/integrations/api/hooks/user/use-users-query.ts
import { useQuery } from '@tanstack/react-query';
import { getUsers, type GetUsersParams } from '../../services/user';

export const useUsersQuery = (params?: GetUsersParams) => {
  return useQuery({
    queryKey: ['users', params],
    queryFn: () => getUsers(params),
    staleTime: 5 * 60 * 1000, // 5 minutes
  });
};
```

```typescript
// ✅ GOOD: src/integrations/api/hooks/user/use-promote-admin.mutation.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { promoteToAdmin } from '../../services/user';

export const usePromoteAdminMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: promoteToAdmin,
    onSuccess: () => {
      // Invalidate users list to refetch with updated roles
      queryClient.invalidateQueries({ queryKey: ['users'] });
      toast.success('User promoted to admin successfully');
    },
    onError: (error: Error) => {
      toast.error(`Failed to promote user: ${error.message}`);
    },
  });
};
```

```typescript
// ✅ GOOD: src/integrations/api/hooks/auth/use-login.mutation.ts
import { useMutation } from '@tanstack/react-query';
import { toast } from 'sonner';
import { login } from '../../services/auth';
import { setAccessToken, setRefreshToken, setUser } from '@/stores/auth-store';

export const useLoginMutation = () => {
  return useMutation({
    mutationFn: login,
    onSuccess: (data) => {
      // Update auth store
      setAccessToken(data.jwt);
      setRefreshToken(data.jwtRefresh);
      setUser(data.user);
      toast.success('Login successful!');
    },
    onError: (error: Error) => {
      toast.error(`Login failed: ${error.message}`);
    },
  });
};
```

```typescript
// ✅ GOOD: src/integrations/api/hooks/todo/use-todos-query.ts
import { useQuery } from '@tanstack/react-query';
import { getTodos, type TodoFilters } from '../../services/todo';

export const useTodosQuery = (filters?: TodoFilters) => {
  return useQuery({
    queryKey: ['todos', filters],
    queryFn: () => getTodos(filters),
    staleTime: 2 * 60 * 1000, // 2 minutes
  });
};
```

```typescript
// ✅ GOOD: src/integrations/api/hooks/todo/use-create-todo-mutation.ts
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { toast } from 'sonner';
import { createTodo, type CreateTodoData } from '../../services/todo';

export const useCreateTodoMutation = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: createTodo,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['todos'] });
      toast.success('Todo created successfully');
    },
    onError: (error: Error) => {
      toast.error(`Failed to create todo: ${error.message}`);
    },
  });
};
```

### 3. Container Component Integration

```typescript
// ✅ GOOD: Container component using hooks (with integrated UI)
"use client";

import { useUsersQuery, usePromoteAdminMutation, useDemoteAdminMutation } from '@/integrations/api';
import { Button } from '@/components/ui/button';
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from '@/components/ui/table';

export const UserManagementContainer = () => {
  // Use React Query hooks - NO direct API calls
  const { data: users, isLoading, error, refetch } = useUsersQuery();
  const promoteAdminMutation = usePromoteAdminMutation();
  const demoteAdminMutation = useDemoteAdminMutation();

  const handlePromote = (userId: string) => {
    promoteAdminMutation.mutate(userId);
  };

  const handleDemote = (userId: string) => {
    demoteAdminMutation.mutate(userId);
  };

  // Handle loading state
  if (isLoading) {
    return <div className="flex justify-center p-8">Loading users...</div>;
  }

  // Handle error state
  if (error) {
    return (
      <div className="p-8 text-center">
        <p className="text-destructive mb-4">Error loading users: {error.message}</p>
        <Button onClick={() => refetch()}>Retry</Button>
      </div>
    );
  }

  // Render UI with business logic
  return (
    <div className="space-y-4">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-bold">User Management</h2>
        <Button onClick={() => refetch()}>Refresh</Button>
      </div>

      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Email</TableHead>
            <TableHead>Role</TableHead>
            <TableHead>Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {users?.map((user) => (
            <TableRow key={user.id}>
              <TableCell>{user.email}</TableCell>
              <TableCell>{user.role}</TableCell>
              <TableCell>
                {user.role === 'user' ? (
                  <Button
                    size="sm"
                    onClick={() => handlePromote(user.id)}
                    disabled={promoteAdminMutation.isPending}
                  >
                    Promote to Admin
                  </Button>
                ) : (
                  <Button
                    size="sm"
                    variant="outline"
                    onClick={() => handleDemote(user.id)}
                    disabled={demoteAdminMutation.isPending}
                  >
                    Demote to User
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
};
```

### ❌ Wrong Implementation - Direct API Calls

```typescript
// ❌ BAD: Container component making direct API calls
import { useState, useEffect } from 'react';
import { fetchUsers, createUser } from '@/api/users'; // Direct import - WRONG

export const UserListContainer = () => {
  const [users, setUsers] = useState([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);

  // ❌ WRONG: Direct API call in useEffect
  useEffect(() => {
    const loadUsers = async () => {
      setIsLoading(true);
      try {
        const userData = await fetchUsers(); // Direct API call - WRONG
        setUsers(userData);
      } catch (err) {
        setError(err);
      }
      setIsLoading(false);
    };

    loadUsers();
  }, []);

  // ❌ WRONG: Direct API call in event handler
  const handleCreateUser = async (userData) => {
    try {
      const newUser = await createUser(userData); // Direct API call - WRONG
      setUsers(prev => [...prev, newUser]);
    } catch (err) {
      setError(err);
    }
  };

  return (
    <UserList 
      users={users} 
      onCreateUser={handleCreateUser}
    />
  );
};
```

## Advanced Patterns

### 1. Conditional and Dependent Queries

```typescript
// ✅ GOOD: Dependent queries with proper enablement
export const useUserProjectsQuery = (userId: string | undefined) => {
  return useQuery({
    queryKey: ['projects', userId],
    queryFn: () => fetchUserProjects(userId!),
    enabled: !!userId, // Only run when userId exists
    staleTime: 5 * 60 * 1000,
  });
};

// Container using dependent queries
export const UserDashboardContainer = ({ userId }: { userId: string }) => {
  const userQuery = useUserQuery(userId);
  const projectsQuery = useUserProjectsQuery(userQuery.data?.id);

  // Handle loading states appropriately
  if (userQuery.isLoading) return <div>Loading user...</div>;
  if (userQuery.error) return <div>Error loading user</div>;
  
  return (
    <UserDashboard
      user={userQuery.data}
      projects={projectsQuery.data}
      isLoadingProjects={projectsQuery.isLoading}
      projectsError={projectsQuery.error}
    />
  );
};
```

### 2. Error Boundary Integration

```typescript
// ✅ GOOD: Error boundaries with React Query
import { QueryErrorResetBoundary } from '@tanstack/react-query';
import { ErrorBoundary } from 'react-error-boundary';

export const UserListWithErrorHandling = () => {
  return (
    <QueryErrorResetBoundary>
      {({ reset }) => (
        <ErrorBoundary
          onReset={reset}
          fallbackRender={({ error, resetErrorBoundary }) => (
            <div>
              <p>Something went wrong: {error.message}</p>
              <button onClick={resetErrorBoundary}>Try again</button>
            </div>
          )}
        >
          <UserListContainer />
        </ErrorBoundary>
      )}
    </QueryErrorResetBoundary>
  );
};
```

### 3. Prefetching Strategies

```typescript
// ✅ GOOD: Prefetching in container components
export const UserListContainer = () => {
  const queryClient = useQueryClient();
  const { data: users } = useUsersQuery();

  const handleUserHover = (userId: string) => {
    // Prefetch user details on hover
    queryClient.prefetchQuery({
      queryKey: userKeys.detail(userId),
      queryFn: () => fetchUser(userId),
      staleTime: 10 * 1000, // Consider fresh for 10s
    });
  };

  return (
    <UserList
      users={users || []}
      onUserHover={handleUserHover}
    />
  );
};
```

## File Organization

### API Integration Structure

```plaintext
src/integrations/api/
├── core/
│   ├── client.ts                      # Axios instance configuration
│   └── token-refresh.ts               # Token refresh interceptor
├── services/
│   ├── auth.ts                        # Auth API functions
│   ├── user.ts                        # User API functions
│   └── todo.ts                        # Todo API functions
├── hooks/
│   ├── auth/
│   │   ├── use-login.mutation.ts      # Login mutation hook
│   │   └── use-register.mutation.ts   # Register mutation hook
│   ├── user/
│   │   ├── use-users-query.ts         # Users query hook
│   │   ├── use-promote-admin.mutation.ts
│   │   └── use-demote-admin.mutation.ts
│   └── todo/
│       ├── use-todos-query.ts         # Todos query hook
│       ├── use-create-todo-mutation.ts
│       ├── use-update-todo-mutation.ts
│       └── use-delete-todo-mutation.ts
└── index.ts                           # Export all hooks for easy imports
```

### Hook File Naming Conventions

- **Queries**: `use-{entity/entities}-query.ts` - Read operations
- **Mutations**: `use-{action}-{entity}.mutation.ts` - Write operations

### Export Pattern

```typescript
// ✅ GOOD: src/integrations/api/index.ts
// Export all hooks for convenient imports
export * from './hooks/auth/use-login.mutation';
export * from './hooks/auth/use-register.mutation';
export * from './hooks/user/use-users-query';
export * from './hooks/user/use-promote-admin.mutation';
export * from './hooks/user/use-demote-admin.mutation';
export * from './hooks/todo/use-todos-query';
export * from './hooks/todo/use-create-todo-mutation';
export * from './hooks/todo/use-update-todo-mutation';
export * from './hooks/todo/use-delete-todo-mutation';

// Usage in components
import { useLoginMutation, useUsersQuery, useCreateTodoMutation } from '@/integrations/api';
```

## Integration with Next.js

### SSR/SSG Pattern

```typescript
// ✅ GOOD: Server-side rendering with React Query
// app/users/page.tsx
import { HydrationBoundary, QueryClient, dehydrate } from '@tanstack/react-query';
import { fetchUsers } from '@/api/users';
import { userKeys } from '@/hooks/use-users-query';
import { UserListContainer } from '@/components/users/user-list-container';

export default async function UsersPage() {
  const queryClient = new QueryClient();

  // Prefetch on server
  await queryClient.prefetchQuery({
    queryKey: userKeys.lists(),
    queryFn: fetchUsers,
  });

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <UserListContainer />
    </HydrationBoundary>
  );
}
```

## Testing Strategy

### 1. Hook Testing

```typescript
// ✅ GOOD: Testing React Query hooks
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useUsersQuery } from './use-users-query';

const createWrapper = () => {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: { retry: false },
      mutations: { retry: false },
    },
  });

  return ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );
};

test('should fetch users', async () => {
  const { result } = renderHook(() => useUsersQuery(), {
    wrapper: createWrapper(),
  });

  await waitFor(() => {
    expect(result.current.data).toEqual([
      { id: '1', name: 'John Doe', email: 'john@example.com' },
    ]);
  });
});
```

### 2. Container Component Testing

```typescript
// ✅ GOOD: Testing container components with mocked hooks
import { render, screen } from '@testing-library/react';
import { vi } from 'vitest';
import { UserListContainer } from './user-list-container';

// Mock the hooks
vi.mock('@/hooks/use-users-query', () => ({
  useUsersQuery: vi.fn(),
  useCreateUserMutation: vi.fn(),
  useDeleteUserMutation: vi.fn(),
}));

test('displays users from hook', () => {
  const mockUsers = [
    { id: '1', name: 'John Doe', email: 'john@example.com' },
  ];

  useUsersQuery.mockReturnValue({
    data: mockUsers,
    isLoading: false,
    error: null,
  });

  render(<UserListContainer />);
  
  expect(screen.getByText('John Doe')).toBeInTheDocument();
});
```

## Critical Anti-Patterns

### ❌ Do Not Make Direct API Calls in Components

```typescript
// ❌ WRONG: Direct API calls in components
const UserProfile = ({ userId }) => {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetchUser(userId).then(setUser); // Don't do this
  }, [userId]);
  
  return <div>{user?.name}</div>;
};
```

### ❌ Do Not Mix API Logic with Component Logic

```typescript
// ❌ WRONG: API error handling in components
const UserList = () => {
  const [users, setUsers] = useState([]);
  const [error, setError] = useState(null);
  
  const loadUsers = async () => {
    try {
      const data = await fetchUsers(); // Don't do this
      setUsers(data);
    } catch (err) {
      setError(err); // Handle errors in hooks instead
    }
  };
};
```

### ❌ Do Not Skip React Query for Server State

```typescript
// ❌ WRONG: Managing server state with useState
const [users, setUsers] = useState([]);
const [isLoading, setIsLoading] = useState(false);

// Use React Query hooks instead
const { data: users, isLoading } = useUsersQuery();
```

## Performance Considerations

1. **Stale Time Configuration**: Set appropriate `staleTime` based on data freshness requirements
2. **Query Key Dependencies**: Include all relevant parameters in query keys
3. **Selective Data Subscription**: Use `select` option to minimize re-renders
4. **Optimistic Updates**: Implement optimistic updates for better UX
5. **Prefetching**: Use strategic prefetching for anticipated user actions

## Summary

- ✅ **Always** wrap API calls in React Query hooks
- ✅ **Always** use hooks in container components, never direct API calls
- ✅ **Always** handle loading and error states in hooks
- ✅ **Always** use proper TypeScript types for API data
- ❌ **Never** make direct API calls from components
- ❌ **Never** manage server state with `useState`
- ❌ **Never** skip proper error handling in hooks